<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OHMS XML to Markdown Converter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: #2c3e50;
            color: white;
            padding: 30px 0;
            margin-bottom: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        h1 {
            text-align: center;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            margin-top: 10px;
            opacity: 0.9;
            font-size: 0.9em;
        }

        .upload-section, .italics-section {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        .file-input-wrapper {
            margin: 20px 0;
            text-align: center;
        }

        .file-input {
            padding: 10px;
            font-size: 1em;
            margin: 10px 0;
        }

        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background 0.3s ease;
            margin: 10px 5px;
        }

        .btn:hover {
            background: #2980b9;
        }

        .btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }

        .btn-success {
            background: #27ae60;
        }

        .btn-success:hover {
            background: #229954;
        }

        .btn-secondary {
            background: #7f8c8d;
        }

        .btn-secondary:hover {
            background: #6c7a7b;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.9em;
        }

        textarea {
            width: 100%;
            min-height: 150px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.9em;
            resize: vertical;
        }

        .preview-section {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: none;
        }

        .preview-section.active {
            display: block;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 2px solid #ecf0f1;
        }

        .preview-content {
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 20px;
            border-radius: 5px;
            background: #fafafa;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
        }

        .detected-titles {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 5px;
            padding: 15px;
            margin: 20px 0;
        }

        .detected-titles h4 {
            color: #856404;
            margin-bottom: 10px;
        }

        .title-tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: #ffc107;
            color: #856404;
            padding: 4px 10px;
            margin: 4px;
            border-radius: 3px;
            font-size: 0.85em;
            font-family: monospace;
        }

        .title-tag-remove {
            cursor: pointer;
            font-weight: bold;
            color: #721c24;
            padding: 0 4px;
            border-radius: 2px;
            transition: background 0.2s;
        }

        .title-tag-remove:hover {
            background: rgba(0,0,0,0.1);
        }

        .status-message {
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            display: none;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            display: block;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            display: block;
        }

        .info-box {
            background: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .info-box ul {
            margin-left: 20px;
        }

        .info-box li {
            margin: 5px 0;
        }

        .help-text {
            font-size: 0.9em;
            color: #666;
            margin-top: 8px;
        }

        .toggle-section {
            cursor: pointer;
            user-select: none;
        }

        .toggle-section:hover {
            opacity: 0.8;
        }

        .collapsible-content {
            margin-top: 15px;
        }

        .dictionary-stats {
            background: #e8f5e9;
            border: 1px solid #4caf50;
            padding: 12px;
            border-radius: 5px;
            margin: 15px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dictionary-stats strong {
            color: #2e7d32;
            font-size: 1.1em;
        }

        .hidden-file-input {
            display: none;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>OHMS XML to Markdown Converter</h1>
            <p class="subtitle">Convert Aviary OHMS XML transcripts to formatted markdown with smart italics</p>
        </div>
    </header>

    <div class="container">
        <div class="upload-section">
            <h2 style="margin-bottom: 20px;">Upload XML File</h2>

            <div class="info-box">
                <h3>What this tool does:</h3>
                <ul>
                    <li>Converts Aviary OHMS XML files to markdown format</li>
                    <li>Extracts metadata and transcript content</li>
                    <li>Automatically detects and italicizes book/publication titles</li>
                    <li>Builds a growing dictionary that improves over time</li>
                    <li>Export/import dictionary across computers</li>
                    <li>Generates downloadable .md file ready for PDF conversion</li>
                </ul>
            </div>

            <div class="file-input-wrapper">
                <input type="file" id="fileInput" class="file-input" accept=".xml" />
                <br>
                <button class="btn" onclick="processFile()">Convert to Markdown</button>
            </div>

            <div id="statusMessage" class="status-message"></div>
        </div>

        <div class="italics-section">
            <h2 class="toggle-section" onclick="toggleSection('italicsContent')">
                üìö Title Dictionary <span style="font-size: 0.8em;">‚ñº</span>
            </h2>
            <div id="italicsContent" class="collapsible-content">
                <div class="dictionary-stats">
                    <div>
                        <strong id="dictionaryCount">0 titles</strong> in your dictionary
                    </div>
                    <div>
                        <button class="btn btn-secondary btn-small" onclick="document.getElementById('importFile').click()">
                            üì• Import
                        </button>
                        <button class="btn btn-secondary btn-small" onclick="exportDictionary()">
                            üì§ Export
                        </button>
                    </div>
                </div>

                <p class="help-text">
                    Add titles that should be italicized (one per line). Your dictionary grows over time and syncs across conversions.
                </p>
                <textarea id="customTitles" placeholder="Enter titles to italicize (one per line):&#10;The New York Times&#10;Carmen&#10;Hamilton&#10;Below Deck"></textarea>

                <div class="button-group">
                    <button class="btn btn-secondary" onclick="saveDictionary()">üíæ Save Dictionary</button>
                    <button class="btn btn-secondary" onclick="sortDictionary()">üî§ Sort A-Z</button>
                    <button class="btn btn-secondary" onclick="clearDictionary()">üóëÔ∏è Clear All</button>
                </div>

                <input type="file" id="importFile" class="hidden-file-input" accept=".txt" onchange="importDictionary(event)">

                <p class="help-text" style="margin-top: 10px;">
                    <strong>Auto-detection:</strong> The app also automatically detects titles using pattern matching (e.g., "the book", "wrote", major publications).
                </p>
            </div>
        </div>

        <div class="preview-section" id="previewSection">
            <div class="preview-header">
                <h2>Preview</h2>
                <div>
                    <button class="btn btn-success" onclick="downloadMarkdown()">
                        ‚¨áÔ∏è Download Markdown
                    </button>
                </div>
            </div>

            <div id="detectedTitles" class="detected-titles" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h4>üìö Detected Titles (will be italicized):</h4>
                    <button class="btn btn-secondary btn-small" onclick="addDetectedToDictionary()">
                        ‚ûï Add All to Dictionary
                    </button>
                </div>
                <p class="help-text" style="margin-bottom: 10px;">
                    Click <strong>‚úï</strong> to remove false positives (e.g., BBC, NPR) that shouldn't be italicized.
                </p>
                <div id="titlesList"></div>
            </div>

            <div class="preview-content" id="previewContent"></div>
        </div>
    </div>

    <script>
        let markdownOutput = '';
        let intervieweeName = '';
        let detectedTitles = new Set();
        let removedTitles = new Set();
        let currentMetadata = null;
        let currentTranscript = null;

        // Load dictionary on page load
        window.addEventListener('DOMContentLoaded', function() {
            loadDictionary();
            updateDictionaryCount();
        });

        function toggleSection(id) {
            const content = document.getElementById(id);
            content.style.display = content.style.display === 'none' ? 'block' : 'none';
        }

        function updateDictionaryCount() {
            const titles = getDictionaryTitles();
            const count = titles.length;
            const label = count === 1 ? 'title' : 'titles';
            document.getElementById('dictionaryCount').textContent = `${count} ${label}`;
        }

        function saveDictionary() {
            const titles = document.getElementById('customTitles').value;
            localStorage.setItem('titleDictionary', titles);
            updateDictionaryCount();
            showStatus('Dictionary saved!', 'success');
        }

        function loadDictionary() {
            const saved = localStorage.getItem('titleDictionary');
            if (saved) {
                document.getElementById('customTitles').value = saved;
            }
        }

        function clearDictionary() {
            if (confirm('Clear entire dictionary? This cannot be undone.')) {
                document.getElementById('customTitles').value = '';
                localStorage.removeItem('titleDictionary');
                updateDictionaryCount();
                showStatus('Dictionary cleared', 'success');
            }
        }

        function sortDictionary() {
            const titles = getDictionaryTitles();
            const sorted = [...new Set(titles)].sort((a, b) =>
                a.toLowerCase().localeCompare(b.toLowerCase())
            );
            document.getElementById('customTitles').value = sorted.join('\n');
            saveDictionary();
            showStatus('Dictionary sorted alphabetically', 'success');
        }

        function exportDictionary() {
            const titles = document.getElementById('customTitles').value;
            if (!titles.trim()) {
                alert('Dictionary is empty. Nothing to export.');
                return;
            }

            const blob = new Blob([titles], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'title-dictionary.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showStatus('Dictionary exported!', 'success');
        }

        function importDictionary(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const imported = e.target.result;
                const existing = document.getElementById('customTitles').value;

                // Merge and deduplicate
                const allTitles = [...new Set([
                    ...existing.split('\n').map(t => t.trim()).filter(t => t),
                    ...imported.split('\n').map(t => t.trim()).filter(t => t)
                ])];

                document.getElementById('customTitles').value = allTitles.join('\n');
                saveDictionary();
                showStatus(`Imported! Dictionary now has ${allTitles.length} titles.`, 'success');
            };
            reader.readAsText(file);

            // Reset input so same file can be imported again
            event.target.value = '';
        }

        function getDictionaryTitles() {
            const text = document.getElementById('customTitles').value;
            return text.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0);
        }

        function addDetectedToDictionary() {
            if (detectedTitles.size === 0) {
                alert('No titles were detected in this conversion.');
                return;
            }

            const existing = getDictionaryTitles();
            const newTitles = Array.from(detectedTitles).filter(title =>
                !existing.some(existing => existing.toLowerCase() === title.toLowerCase())
            );

            if (newTitles.length === 0) {
                showStatus('All detected titles are already in your dictionary!', 'success');
                return;
            }

            const allTitles = [...existing, ...newTitles];
            document.getElementById('customTitles').value = allTitles.join('\n');
            saveDictionary();

            const label = newTitles.length === 1 ? 'title' : 'titles';
            showStatus(`Added ${newTitles.length} new ${label} to dictionary!`, 'success');
        }

        function showStatus(message, type) {
            const div = document.getElementById('statusMessage');
            div.className = 'status-message ' + type;
            div.textContent = message;
            setTimeout(() => {
                div.style.display = 'none';
            }, 3000);
        }

        function processFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];

            if (!file) {
                showStatus('Please select a file first', 'error');
                return;
            }

            if (!file.name.endsWith('.xml')) {
                showStatus('Please select an XML file', 'error');
                return;
            }

            showStatus('Processing file...', 'success');
            detectedTitles = new Set();
            removedTitles = new Set();

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const xmlText = e.target.result;
                    const markdown = convertToMarkdown(xmlText);

                    markdownOutput = markdown;
                    document.getElementById('previewContent').textContent = markdown;
                    document.getElementById('previewSection').classList.add('active');

                    // Show detected titles
                    displayDetectedTitles();

                    showStatus('Conversion successful!', 'success');

                    // Scroll to preview
                    document.getElementById('previewSection').scrollIntoView({ behavior: 'smooth' });
                } catch (error) {
                    showStatus('Error: ' + error.message, 'error');
                    console.error('Conversion error:', error);
                }
            };

            reader.onerror = function() {
                showStatus('Error reading file', 'error');
            };

            reader.readAsText(file);
        }

        function displayDetectedTitles() {
            const titlesDiv = document.getElementById('detectedTitles');
            const listDiv = document.getElementById('titlesList');

            if (detectedTitles.size > 0) {
                titlesDiv.style.display = 'block';
                listDiv.innerHTML = Array.from(detectedTitles)
                    .sort()
                    .map(title => `
                        <span class="title-tag">
                            ${escapeHtml(title)}
                            <span class="title-tag-remove" onclick="removeDetectedTitle('${escapeHtml(title).replace(/'/g, "\\'")}')">‚úï</span>
                        </span>
                    `)
                    .join('');
            } else {
                titlesDiv.style.display = 'none';
            }
        }

        function removeDetectedTitle(title) {
            // Add to removed list
            removedTitles.add(title);

            // Remove from detected set
            detectedTitles.delete(title);

            // Reprocess the markdown without this title
            reprocessMarkdown();

            // Update display
            displayDetectedTitles();

            showStatus(`Removed "${title}" - won't be italicized`, 'success');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function detectAndItalicizeTitles(text) {
            // Get custom titles from dictionary
            const customTitles = getDictionaryTitles();

            // Built-in known publications
            const knownPublications = [
                'The New York Times',
                'New York Times',
                'The Washington Post',
                'The Wall Street Journal',
                'The Guardian',
                'Time Magazine',
                'Newsweek',
                'The Atlantic',
                'The New Yorker',
                'Harvard Business Review',
                'Nature',
                'Science',
                'JAMA',
                'The Lancet',
                'BBC',
                'NPR',
                'PBS'
            ];

            // Combine all titles to check
            const allTitles = [...new Set([...customTitles, ...knownPublications])];

            // Sort by length (longest first) to avoid partial matches
            allTitles.sort((a, b) => b.length - a.length);

            // Apply exact matches for known titles
            allTitles.forEach(title => {
                // Skip if this title was manually removed
                if ([...removedTitles].some(removed => removed.toLowerCase() === title.toLowerCase())) {
                    return;
                }

                // Case-insensitive search but preserve original case
                const regex = new RegExp('\\b' + escapeRegex(title) + '\\b', 'gi');
                const matches = text.match(regex);
                if (matches) {
                    matches.forEach(match => {
                        // Skip if this match was manually removed
                        if ([...removedTitles].some(removed => removed.toLowerCase() === match.toLowerCase())) {
                            return;
                        }

                        detectedTitles.add(match);
                        // Replace with italicized version
                        text = text.replace(new RegExp('\\b' + escapeRegex(match) + '\\b', 'g'), `*${match}*`);
                    });
                }
            });

            // Pattern-based detection
            text = detectPatternBasedTitles(text);

            return text;
        }

        function detectPatternBasedTitles(text) {
            // Pattern 1: After "the book"
            text = text.replace(/\b(the book|the novel|the memoir)\s+([A-Z][A-Za-z\s&'-]+?)(?=\s+(?:by|,|\.|\n|was|is|‚Äî))/g,
                (match, prefix, title) => {
                    const cleanTitle = title.trim();
                    // Skip if manually removed
                    if ([...removedTitles].some(removed => removed.toLowerCase() === cleanTitle.toLowerCase())) {
                        return match;
                    }
                    detectedTitles.add(cleanTitle);
                    return `${prefix} *${cleanTitle}*`;
                });

            // Pattern 2: After "wrote", "published", "authored"
            text = text.replace(/\b(wrote|published|authored|co-authored)\s+([A-Z][A-Za-z\s&'-]+?)(?=\s+(?:in|,|\.|\n|for))/g,
                (match, verb, title) => {
                    const cleanTitle = title.trim();
                    if (cleanTitle.split(' ').length <= 6) { // Reasonable title length
                        // Skip if manually removed
                        if ([...removedTitles].some(removed => removed.toLowerCase() === cleanTitle.toLowerCase())) {
                            return match;
                        }
                        detectedTitles.add(cleanTitle);
                        return `${verb} *${cleanTitle}*`;
                    }
                    return match;
                });

            // Pattern 3: After "the journal", "the article"
            text = text.replace(/\b(the journal|the magazine|the newspaper)\s+([A-Z][A-Za-z\s&'-]+?)(?=\s+(?:,|\.|\n|in|and))/g,
                (match, prefix, title) => {
                    const cleanTitle = title.trim();
                    // Skip if manually removed
                    if ([...removedTitles].some(removed => removed.toLowerCase() === cleanTitle.toLowerCase())) {
                        return match;
                    }
                    detectedTitles.add(cleanTitle);
                    return `${prefix} *${cleanTitle}*`;
                });

            // Pattern 4: "in [Publication]" pattern
            text = text.replace(/\b(in|for)\s+(The\s+[A-Z][A-Za-z\s]+?)(?=\s+(?:,|\.|\n|and|that))/g,
                (match, prep, title) => {
                    const cleanTitle = title.trim();
                    if (cleanTitle.split(' ').length <= 5) {
                        // Skip if manually removed
                        if ([...removedTitles].some(removed => removed.toLowerCase() === cleanTitle.toLowerCase())) {
                            return match;
                        }
                        detectedTitles.add(cleanTitle);
                        return `${prep} *${cleanTitle}*`;
                    }
                    return match;
                });

            return text;
        }

        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function convertToMarkdown(xmlText) {
            // Parse XML
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

            // Check for parsing errors
            const parserError = xmlDoc.querySelector('parsererror');
            if (parserError) {
                throw new Error('Invalid XML file');
            }

            // Find record element
            const record = xmlDoc.querySelector('record');
            if (!record) {
                throw new Error('No <record> element found in XML');
            }

            // Extract metadata
            const getVal = (tag) => {
                const el = record.querySelector(tag);
                return el ? el.textContent.trim() : '';
            };

            const metadata = {
                title: getVal('title'),
                date: getVal('date_nonpreferred_format'),
                interviewee: getVal('interviewee'),
                interviewer: getVal('interviewer'),
                description: getVal('description'),
                repository: getVal('repository'),
                duration: getVal('duration'),
                vttTranscript: getVal('vtt_transcript')
            };

            intervieweeName = metadata.interviewee.split(' ').pop().toLowerCase();

            // Parse transcript (store original without italics)
            const transcript = parseVTT(metadata.vttTranscript, metadata.interviewee);

            // Store original data for reprocessing
            currentMetadata = JSON.parse(JSON.stringify(metadata));
            currentTranscript = JSON.parse(JSON.stringify(transcript));

            // Apply italics to copies
            const processedTranscript = JSON.parse(JSON.stringify(transcript));
            processedTranscript.forEach(segment => {
                segment.text = detectAndItalicizeTitles(segment.text);
            });

            // Also apply to description
            const processedMetadata = JSON.parse(JSON.stringify(metadata));
            processedMetadata.description = detectAndItalicizeTitles(processedMetadata.description);

            // Generate markdown
            return generateMarkdown(processedMetadata, processedTranscript);
        }

        function reprocessMarkdown() {
            if (!currentMetadata || !currentTranscript) {
                console.error('No data to reprocess');
                return;
            }

            // Reset detected titles for this reprocess
            detectedTitles = new Set();

            // Reapply italics to fresh copies (detection now respects removedTitles)
            const processedTranscript = JSON.parse(JSON.stringify(currentTranscript));
            processedTranscript.forEach(segment => {
                segment.text = detectAndItalicizeTitles(segment.text);
            });

            const processedMetadata = JSON.parse(JSON.stringify(currentMetadata));
            processedMetadata.description = detectAndItalicizeTitles(processedMetadata.description);

            // Regenerate markdown
            markdownOutput = generateMarkdown(processedMetadata, processedTranscript);
            document.getElementById('previewContent').textContent = markdownOutput;
        }

        function parseVTT(vttText, intervieweeName) {
            const lines = vttText.split('\n');
            const segments = [];
            const lastName = intervieweeName.split(' ').pop().toUpperCase();

            for (let line of lines) {
                line = line.trim();

                // Skip timestamps, notes, etc
                if (!line || line.includes('-->') || line.startsWith('NOTE') || line === 'WEBVTT') {
                    continue;
                }

                // Find speaker tag
                const match = line.match(/<v ([^>]+)>/);
                if (match) {
                    const speakerTag = match[1].trim();
                    const speaker = speakerTag === 'Q' ? 'Q' : lastName;
                    const text = line.replace(/<v [^>]+>/g, '').trim();

                    segments.push({ speaker, text });
                }
            }

            return segments;
        }

        function generateMarkdown(meta, transcript) {
            const lastName = meta.interviewee.split(' ').pop().toUpperCase();
            let md = '';

            // Title page
            md += 'ASC Alumni Oral History Project\n';
            md += 'Annenberg School for Communication Library Archives\n';
            md += 'University of Pennsylvania\n';
            md += 'Philadelphia, PA\n\n\n\n\n\n';
            md += '# ' + meta.interviewee.toUpperCase() + '\n\n';
            md += 'interviewed and transcribed by\n\n';
            md += meta.interviewer.toUpperCase() + '\n\n';
            md += 'recorded by\n\n';
            md += '[RECORDER NAME]\n\n\n\n';
            md += '*' + meta.date + '*\n\n\n\n';
            md += 'Philadelphia, PA\n\n';
            md += 'Creative Commons CC BY-NC 4.0\n\n';
            md += '---\n\n';

            // Abstract
            md += '## ABSTRACT\n\n' + meta.description + '\n\n';

            // Restrictions
            md += '## RESTRICTIONS\n\n';
            md += 'None\n\n';

            // Format
            md += '## FORMAT\n\n';
            md += 'Interview. Video recordings at the Annenberg School for Communication, University of Pennsylvania, 3620 Walnut Street, Philadelphia, PA 19104, USA. One mp4 file of ' + meta.duration + '.\n\n';

            // Transcript info
            md += '## TRANSCRIPT\n\n';
            md += 'Transcribed by ' + meta.interviewer + '. Audited for accuracy and edited for clarity by ' + meta.interviewer + '. Transcript reviewed and approved by ' + meta.interviewee + ', ' + meta.interviewer + ', and [REVIEWER NAME]. Transcript [XX] pages.\n\n';

            // Citation forms
            md += '## BIBLIOGRAPHY AND CITATION FORMS\n\n';
            md += '### Video recording\n\n';
            md += '**Bibliography:** ' + meta.interviewee + '. Interview by ' + meta.interviewer + '. Video recording, ' + meta.date + '. ASC Alumni Oral History Project, Annenberg School for Communication Library Archives, University of Pennsylvania. ';
            md += '**Footnote example:** ' + meta.interviewee + ', interview by ' + meta.interviewer + ', video recording, ' + meta.date + ', ASC Alumni Oral History Project, Annenberg School for Communication Library Archives, University of Pennsylvania.\n\n';

            md += '### Transcript\n\n';
            md += '**Bibliography:** ' + meta.interviewee + '. Interview by ' + meta.interviewer + '. Transcript of video recording, ' + meta.date + '. ASC Alumni Oral History Project, Annenberg School for Communication Library Archives, University of Pennsylvania. ';
            md += '**Footnote example:** ' + meta.interviewee + ', interview by ' + meta.interviewer + ', transcript of video recording, ' + meta.date + ', ASC Alumni Oral History Project, Annenberg School for Communication Library Archives, University of Pennsylvania, pp. XX‚ÄìXX.\n\n';

            md += '---\n\n';

            // Transcript header
            md += '# Transcript of interview conducted ' + meta.date + ', with ' + meta.interviewee.toUpperCase() + '\n\n';
            md += 'Philadelphia, PA\n\n';
            md += 'Interviewed by ' + meta.interviewer + '\n\n';
            md += '---\n\n';

            // Transcript content
            for (const seg of transcript) {
                if (seg.speaker === 'Q') {
                    md += 'Q: ' + seg.text + '\n\n';
                } else {
                    md += lastName + ': ' + seg.text + '\n\n';
                }
            }

            md += '\n---\n\nEND OF INTERVIEW\n';

            return md;
        }

        function downloadMarkdown() {
            if (!markdownOutput) {
                alert('No markdown content to download');
                return;
            }

            const blob = new Blob([markdownOutput], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = intervieweeName + '_transcript.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
